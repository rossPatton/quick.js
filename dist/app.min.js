(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @requires query
 * @description add a node or nodes to the existing selection
 * @param	{string} [sel] the string (selector) used to query the dom
 * @returns {Object} [this] like most methods, returns parent object
 */
var add = function add(sel) {
	var _this = this;

	// iterate over new selection and current
	// if no dupe, push to current selection
	this.query(sel).forEach(function (el) {
		return _this.sel.forEach(function (el2) {
			if (!el.isEqualNode(el2)) {
				return _this.sel.push(el);
			}
		});
	});

	return this;
};

module.exports = add;

},{}],2:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description add the class or classes to the selection
 * @param	{string} [classes] the classes to add, separated by a space
 * @returns {Object} [this] like most methods, returns parent object
 */
var addClass = function addClass(classes) {
	var _this = this;

	this.each(function (el) {
		return classes.split(' ').forEach(function (c) {
			if (el.className.indexOf(c) === -1) {
				return _this.raf(function () {
					el.className += ' ' + c;
				});
			}
		});
	});

	return this;
};

module.exports = addClass;

},{}],3:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @requires isNode
 * @description appends dom node or nodes to the dom, after each node in the selection
 * @param {Object} [appendMe] the node to append to the dom
 * @returns {Object} [this] like most methods, returns parent object
 */
var after = function after(appendMe) {
	var _this = this;

	// if passed a dom node directly, check it and append it
	if (this.isNode(appendMe)) {
		this.raf(this.each(function (el) {
			return el.parentNode.insertBefore(appendMe.cloneNode(), el.nextSibling);
		}));
	}
	// return dom.insertBefore(tmp.firstChild.cloneNode(true), dom.firstChild)
	else if (typeof appendMe === 'string') {
		(function () {
			var tmp = document.createElement('div');
			tmp.insertAdjacentHTML('afterbegin', appendMe);

			_this.raf(_this.each(function (el) {
				return el.parentNode.insertBefore(tmp.firstChild.cloneNode(true), el.nextSibling);
			}));
		})();
	}

	return this;
};

module.exports = after;

},{}],4:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @requires isNode
 * @description appends dom nodes to the dom, and the end of each item in the selection
 * @param {Object} [appendMe] the dom node to append to the dom
 * @returns {Object} [this] like most methods, returns parent object
 */
var append = function append(appendMe) {
	var _this = this;

	// if passed a dom node directly, check it and append it
	if (this.isNode(appendMe)) {
		this.raf(this.each(function (el) {
			return el.appendChild(appendMe.cloneNode());
		}));
	} else if (typeof appendMe === 'string') {
		(function () {
			var tmp = document.createElement('div');
			tmp.insertAdjacentHTML('afterbegin', appendMe);
			_this.raf(_this.each(function (el) {
				return el.appendChild(tmp.firstChild.cloneNode(true));
			}));
		})();
	}

	return this;
};

module.exports = append;

},{}],5:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description appends dom nodes to the dom, and the end of each item in the selection
 * @param {string} [get] returns the matching attribute if there is one
 * @param {string} [set] sets an attribute on the selection
 * @returns {Object} [this | string] if getting, returns the attr, if setting, returns parent Object
 */
var attr = function attr(get, set) {
  if (set) {
    this.each(function (el) {
      return el.setAttribute(get, set);
    });
  }

  // if getting, return the attr
  // if setting, set attributes and continue chaining
  return !set ? this.sel[0].getAttribute(get) : this;
};

module.exports = attr;

},{}],6:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @requires isNode
 * @description appends dom nodes before each node in the selection
 * @param {Object} [prependMe] the node to prepend to the dom
 * @returns {Object} [this] like most methods, returns parent object
 */
var before = function before(prependMe) {
	var _this = this;

	// if passed a dom node directly, check it and append it
	if (this.isNode(prependMe)) {
		this.raf(this.each(function (el) {
			return el.parentNode.insertBefore(prependMe.cloneNode(), el.previousSibling);
		}));
	}
	// return dom.insertBefore(tmp.firstChild.cloneNode(true), dom.firstChild)
	else if (typeof prependMe === 'string') {
		(function () {
			var tmp = document.createElement('div');
			tmp.insertAdjacentHTML('afterbegin', prependMe);
			_this.raf(_this.each(function (el) {
				return el.parentNode.insertBefore(tmp.firstChild.cloneNode(true), el.previousSibling);
			}));
		})();
	}

	return this;
};

module.exports = before;

},{}],7:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @requires camelCase
 * @description gets or sets css properties on the selection
 * @param {Object | string} [styles] string for an individual style, object for many styles
 * @returns {Object | string} the matching style rule if getting, or the parent Object if setting
 */
var css = function css(styles) {
	var isString = typeof styles === 'string';

	// set css values of passed in object on every element in the selection
	if (!isString && typeof styles === 'object') {
		this.raf(this.each(function (el) {
			for (var key in styles) {
				if (styles.hasOwnProperty(key)) {
					el.style[key] = styles[key];
				}
			}
		}));
	}

	// if getting, return the matching css value of the first item in the selection
	// if setting, set css values on entire selection and continue chaining
	return isString ? this.sel[0].style[this.camelCase(styles)] : this;
};

module.exports = css;

},{}],8:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description iterate over selection, pass each item to callback
 * @param {Function} [cb] the callback
 * @returns {Object} [this] like most methods, returns parent object
 */
var each = function each(cb) {
  var len = this.sel.length;
  var i = 0;

  for (i; i < len; i++) {
    cb(this.sel[i], i, this.sel);
  }

  return this;
};

module.exports = each;

},{}],9:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description remove all child nodes from an element
 * @returns {Object} [this] like most methods, returns parent object
 */
var empty = function empty() {
	var _this = this;

	this.each(function (el) {
		while (el.firstChild) {
			_this.raf(el.removeChild(el.firstChild));
		}
	});

	return this;
};

module.exports = empty;

},{}],10:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description return specific item in selection, from beginning or from the end
				if pos is out of bounds, returns empty selection
 * @param {number} [pos] the index of the selection to retrieve
 * @returns {Object} [this] like most methods, returns parent object
 */
var eq = function eq(pos) {
	if (pos < this.sel.length) {
		this.sel = [this.sel[pos]]
		// pos > 0 ? [ this[0][pos] ] : [ this[0][this[0].length + pos] ]
		;
	} else {
		this.sel = [];
	}

	return this;
};

module.exports = eq;

},{}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * @module
 * @public
 * @description a really basic extend function for now
 * @param {Object} [source] the object to copy the method from
 * @returns {Object} [this] like most methods, returns parent object
 */
var extend = function extend(source) {
  for (var method in source) {
    if (source.hasOwnProperty(method)) {
      Object.getPrototypeOf(this)[method] = source[method];
    }
  }

  return this;
};

exports['default'] = extend;
module.exports = exports['default'];

},{}],12:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @requires query
 * @description compares two selections and returns only the ones that are in both
 * @param {Object} [sel] the selector to use as the comparison selection
 * @param {boolean} [doWeFilter] if true we return a new selection of overlapping els only
 * @returns {Object | boolean} boolean if not filtering, parent Object otherwise
 */
var has = function has(sel, doWeFilter) {
	var _this = this;

	var compare = this.query(sel);

	// returns true or false depending on whether or not
	// the new selection overlaps with the old selection
	var hasEl = compare.some(function (el) {
		return _this.sel.some(function (el2) {
			return el.isEqualNode(el2);
		});
	});

	// set the result to be the new selection, if filter passed in
	// only do if there is overlap, otherwise just return the existing selection
	if (hasEl && doWeFilter === 'filter') {
		(function () {
			var filtered = [];

			// compare new selection (compare) to existing selection (this[0])
			// filtered is the result of the filter, flattened (which seems unecessary but...)
			compare.forEach(function (el1) {
				return filtered.push(_this.sel.filter(function (el2) {
					return el1.isEqualNode(el2);
				}));
			});

			filtered = [].concat.apply([], filtered);

			// set the overlap to be the new selection
			_this.sel = filtered;
		})();
	}

	// if using haz as a boolean, just return hasEl
	// if using haz as a filter then keep chaining
	return doWeFilter === 'filter' ? this : hasEl;
};

module.exports = has;

},{}],13:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description look for a particular class in the first el of the selection
 * @param {string} [classes] the class(es) to look for (separated by a space)
 * @returns {boolean} true if el has class, false if not
 */
var hasClass = function hasClass(classes) {
  var _this = this;

  return classes.split(' ').every(function (c) {
    return _this.sel[0].className.indexOf(c) !== -1;
  });
};

module.exports = hasClass;

},{}],14:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description gets or sets the height on an element or array of elements
 * @param {string} [val] if passed in, set the height to this value
 * @returns {number | Object} the height if getting, parent Object if setting
 */
var height = function height(val) {
	// set the height if a value was passed in
	if (val) {
		this.raf(this.each(function (el) {
			return el.style.height = parseInt(val, 10);
		}));
	}

	// if just getting the height, return the height
	// else if setting the height, set height above and keep chaining
	return !val ? this.sel[0].clientHeight : this;
};

module.exports = height;

},{}],15:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @TODO wait for css transitions
 * @description hide an element, while waiting for css transitions to finish
 * @returns {Object} [this] like most methods, returns parent object
 */
var hide = function hide() {
	var _this = this;

	this.each(function (el) {
		if (el.style.display !== 'none') {
			_this.raf(function () {
				el.style.display = 'none';
			});
		}
	});
	return this;
};

module.exports = hide;

},{}],16:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @requires toArray
 * @TODO DOMParser is cool but def not the most compatible way of doing this
 * @TODO i feel like the return values here are off (opposite of what they should be i think)
 * @description gets or sets (safely) html content of a dom node
 * @param {string} [set] the html to (safely) insert if passed in
 * @returns {Object | string} the html of the el, or the parent Object
 */
var html = function html(set) {
	this.empty();

	var htmlArr = this.toArray(new DOMParser().parseFromString(set, 'text/html').body.children);

	this.raf(this.each(function (el) {
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = htmlArr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var node = _step.value;

				el.appendChild(node.cloneNode(true));
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator['return']) {
					_iterator['return']();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	}));

	return set ? this.sel[0].innerHTML : this;
};

module.exports = html;

},{}],17:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description remove event listeners (needs more work, the this binding makes it hard to compare callbacks)
 * @param {string} [events] the event(s) to remove from the selection
 * @param {Function} [cb] the callback to remove from the selection
 * @returns {Object} [this] like most methods, returns parent object
 */
var off = function off(events, cb) {
	var _this = this;

	this.each(function (el) {
		return events.split(' ').forEach(function (ev) {
			return _this.listeners.forEach(function (listener) {
				if (ev !== listener.ev || !Object.is(cb, listener.cb)) {
					throw Error;
				}

				return el.removeEventListener(listener.ev, listener.cb);
			});
		});
	});

	return this;
};

module.exports = off;

},{}],18:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @TODO need to promote the better practice of putting evs on the body
 * @description attach event listeners to the selection
 * @param {string} [events] the event(s) to attach to the selection
 * @param {Function} [cb] the callback to attach to the selection
 * @returns {Object} [this] like most methods, returns parent object
 */
var on = function on(events, cb) {
	var _this = this;

	this.each(function (el) {
		return events.split(' ').forEach(function (ev) {
			var l = {
				el: el,
				ev: ev,
				cb: cb
			};

			_this.listeners.push(l);

			return el.addEventListener(l.ev, l.cb);
		});
	});

	return this;
};

module.exports = on;

},{}],19:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @requires isNode
 * @description prepends dom nodes using those nodes directly or a string
 * @param {Object} [prependMe] the dom node to prepend to the dom
 * @returns {Object} [this] like most methods, returns parent object
 */
var prepend = function prepend(prependMe) {
	var _this = this;

	// if passed a dom node directly, check it and append it
	if (this.isNode(prependMe)) {
		this.raf(this.each(function (el) {
			return el.insertBefore(prependMe.cloneNode(), el.firstChild);
		}));
	} else if (typeof prependMe === 'string') {
		(function () {
			var tmp = document.createElement('div');
			tmp.insertAdjacentHTML('afterbegin', prependMe);
			_this.raf(_this.each(function (el) {
				return el.insertBefore(tmp.firstChild.cloneNode(true), el.firstChild);
			}));
		})();
	}

	return this;
};

module.exports = prepend;

},{}],20:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description get prop (first match) or set prop on all matching
 * @param {string} [get] get matching property of the first el in the selection
 * @param {string} [set] set property on the entire selection
 * @returns {string | Object} the value of property, or the parent Object
 */
var prop = function prop(get, set) {
	// if set if string, we pass it as the value
	// else we just pass in the config object
	// ternary lets ppl pass in a value here, or a config object
	if (set) {
		this.each(function (el) {
			return el[get] = set;
		});
	}

	// if getting, just return the prop (bracket notation needed: get is a str)
	// if setting, we set props above and continue chaining
	return !set ? this.sel[0][get] : this;
};

module.exports = prop;

},{}],21:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description remove the selection from the DOM
 * @returns {Object} [this] like most methods, returns parent object
 */
var remove = function remove() {
  this.raf(this.each(function (el) {
    return el.parentNode.removeChild(el);
  }));
  return this;
};

module.exports = remove;

},{}],22:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description remove classes from the selection
 * @param	{string} [classes] the classes to remove, separated by a space
 * @returns {Object} [this] like most methods, returns parent object
 */
var removeClass = function removeClass(classes) {
	this.each(function (el) {
		return classes.split(' ').forEach(function (c) {
			if (el.className.indexOf(c) === -1) {
				return;
			}
			el.className = el.className.replace(c, '')
			// el.className = this.raf( function() {
			// 	return el.className.replace( c, '' )
			// } )
			;
		});
	});

	return this;
};

module.exports = removeClass;

},{}],23:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @TODO wait for css transitions
 * @description show an element, while waiting for css transitions to finish
 * @returns {Object} [this] like most methods, returns parent object
 */
var show = function show() {
	var _this = this;

	this.each(function (el) {
		if (el.style.display === 'none') {
			_this.raf(function () {
				el.style.display = 'block';
			});
		}
	});
	return this;
};

module.exports = show;

},{}],24:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @TODO wait for css transitions
 * @description just gets the length of the current selection
 * @returns {number} the length
 */
var size = function size() {
  return this.sel.length;
};

module.exports = size;

},{}],25:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description narrow the selection
 * @param {number} [pos1] starting index for new selection
 * @param {number} [pos2] end index for new selection
 * @returns {Object} [this] like most methods, returns parent object
 */
var slice = function slice(pos1, pos2) {
  this.sel = this.sel.slice(pos1, pos2);
  return this;
};

module.exports = slice;

},{}],26:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description get text of first el in the selection
 * @param {string} [set] if passed in, sets the text of the selection
 * @returns {string | Object} the textContext of the first el, or the parent Object
 */
var text = function text(set) {
	var txt = [];

	// get textContent of first node in selection
	if (typeof set === 'undefined') {
		var nodes = this.toArray(this.sel[0].childNodes);

		// we do it this way so we don't get run-on sentences
		nodes.forEach(function (node) {
			if (node.nodeType === 1 || node.nodeType === 3) {
				txt.push(node.textContent);
			}
		});
	}
	// else set textContent of all nodes in selection
	else {
		this.each(function (el) {
			var setTxt = document.createTextNode(set).textContent;

			if (el.nodeType === 1 || el.nodeType === 11 || el.nodeType === 9) {
				el.textContent = setTxt
				// this.raf( function () {
				// 	el.textContent = setTxt
				// } )
				;
			}
		});
	}

	// if just getting, we return the total txt
	// if setting, we set above and continue chaining
	return typeof set === 'undefined' ? txt.join(' ') : this;
};

module.exports = text;

},{}],27:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description toggles classes (add or remove depending on context)
 * @param {string} [classes] the classes to toggle
 * @returns {Object} [this] like most methods, returns parent object
 */
var toggleClass = function toggleClass(classes) {
	var _this = this;

	this.each(function (el) {
		return classes.split(' ').forEach(function (c) {
			if (el.className.indexOf(c) === -1) {
				_this.raf(function () {
					el.className += ' ' + c;
				});
			} else {
				el.className = _this.raf(function () {
					return el.className.replace(c, '');
				});
			}
		});
	});

	return this;
};

module.exports = toggleClass;

},{}],28:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description gets or sets the height on the selection
 * @param {string} [set] the value to set the width of the selection to
 * @returns {Object} [this] like most methods, returns parent object
 */
var width = function width(set) {
  if (typeof set !== 'undefined') {
    this.raf(this.each(function (el) {
      return el.style.width = '' + set;
    }));
  }

  return typeof set === 'undefined' ? this.sel[0].clientWidth : this;
};

module.exports = width;

},{}],29:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @requires isNode
 * @description wrap the selection with the passed in dom element
 * @param {Object} [dom] the dom node to wrap the selection with
 * @returns {Object} [this] like most methods, returns parent object
 */
var wrap = function wrap(dom) {
	var _this = this;

	// if passed a dom node directly, check it and append it
	if (this.isNode(dom)) {
		this.each(function (el) {
			var w = dom.cloneNode(true);
			w.appendChild(el.cloneNode(true));

			return _this.raf(el.parentNode.replaceChild(w, el));
		});
	} else if (typeof dom === 'string') {
		(function () {
			var tmp = document.createElement('div');
			tmp.insertAdjacentHTML('afterbegin', dom);

			_this.each(function (el) {
				var w = tmp.firstChild.cloneNode(true);

				w.appendChild(el.cloneNode(true));

				return _this.raf(el.parentNode.replaceChild(w, el));
			});
		})();
	}

	return this;
};

module.exports = wrap;

},{}],30:[function(require,module,exports){
'use strict';

var proto = {
	add: require('./methods/add'),
	addClass: require('./methods/addClass'),
	after: require('./methods/after'),
	append: require('./methods/append'),
	attr: require('./methods/attr'),
	before: require('./methods/before'),
	camelCase: require('./utils/camelCase'),
	css: require('./methods/css'),
	each: require('./methods/each'),
	empty: require('./methods/empty'),
	eq: require('./methods/eq'),
	extend: require('./methods/extend'),
	has: require('./methods/has'),
	hasClass: require('./methods/hasClass'),
	height: require('./methods/height'),
	hide: require('./methods/hide'),
	html: require('./methods/html'),
	isNode: require('./utils/isNode'),
	off: require('./methods/off'),
	on: require('./methods/on'),
	prepend: require('./methods/prepend'),
	prop: require('./methods/prop'),
	query: require('./utils/query'),
	raf: require('./utils/raf'),
	remove: require('./methods/remove'),
	removeClass: require('./methods/removeClass'),
	show: require('./methods/show'),
	size: require('./methods/size'),
	slice: require('./methods/slice'),
	text: require('./methods/text'),
	toArray: require('./utils/toArray'),
	toggleClass: require('./methods/toggleClass'),
	width: require('./methods/width'),
	wrap: require('./methods/wrap')
};

module.exports = proto;

},{"./methods/add":1,"./methods/addClass":2,"./methods/after":3,"./methods/append":4,"./methods/attr":5,"./methods/before":6,"./methods/css":7,"./methods/each":8,"./methods/empty":9,"./methods/eq":10,"./methods/extend":11,"./methods/has":12,"./methods/hasClass":13,"./methods/height":14,"./methods/hide":15,"./methods/html":16,"./methods/off":17,"./methods/on":18,"./methods/prepend":19,"./methods/prop":20,"./methods/remove":21,"./methods/removeClass":22,"./methods/show":23,"./methods/size":24,"./methods/slice":25,"./methods/text":26,"./methods/toggleClass":27,"./methods/width":28,"./methods/wrap":29,"./utils/camelCase":31,"./utils/isNode":32,"./utils/query":33,"./utils/raf":34,"./utils/toArray":35}],31:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description convert a lowercase-dash string to a camelCase string
 * @param {string} [str] the string to convert
 * @returns {string} the new camelCased string
 */
var camelCase = function camelCase(str) {
  return str.replace(/-[a-z]/gi, function (s) {
    return s.replace('-', '').toUpperCase();
  });
};

module.exports = camelCase;

},{}],32:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @description sanity check to make sure we've got a dom node
 * @param {object} node [the object we're checking for node-ness]
 * @returns {boolean} whether or not the node is a node
 */
var isNode = function isNode(node) {
	var amNode = false;

	// bit of a hacky x-browser workaround here
	if (typeof node === 'object' && node.nodeType && node.cloneNode && (node.nodeType === 1 || node.nodeType === 3)) {

		amNode = true;
	}

	return amNode;
};

module.exports = isNode;

},{}],33:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @requires toArray
 * @description save the result of a dom query
 * 	            this is accessible app wide, so you don't have to constantly
 * 	            do dom lookups for each thing every time a function is called
 * 	            also gives you an array, which is more usable than a nodelist
 * @see https://eamann.com/tech/selector-caching-jquery/
 * @param {string} [sel] [the string we'll use to get dom nodes]
 * @param {parent} [obj] [where to search]
 * @param {bool} [bust] [if true, we ignore the cache and get it fresh]
 * @return {array} [our node list, as an array]
 */
var query = function query(sel) {
  var parent = arguments[1] === undefined ? document : arguments[1];
  var bust = arguments[2] === undefined ? false : arguments[2];

  this.cache = this.cache || {};

  if (bust === 'bust' || typeof this.cache['' + parent.nodeName + ':' + sel] === 'undefined') {
    this.cache['' + parent.nodeName + ':' + sel] = this.toArray(parent.querySelectorAll(sel));
  }

  // pretty much just so i can test the cache object better for now
  return this.cache['' + parent.nodeName + ':' + sel];
};

module.exports = query;

},{}],34:[function(require,module,exports){
'use strict';

/**
 * @module
 * @public
 * @requires toArray
 * @description just a shorthand for window.requestAnimationFrame
 *              if browser doesnt support raf, use a polyfill (not bundled with quick)
 *              if server side, just call the
 * @param {string} [sel] [the string we'll use to get dom nodes]
 * @param {parent} [obj] [where to search]
 * @param {bool} [bust] [if true, we ignore the cache and get it fresh]
 * @return {array} [our node list, as an array]
 */
if (typeof window !== 'undefined') {
  module.exports = window.requestAnimationFrame;
}
// if on server side dont bother with raf
else {
  module.exports = function (cb) {
    return cb();
  };
}

},{}],35:[function(require,module,exports){
/**
 * @description converts nodeLists (and other things) to arrays
 *							(allows you to use array methods on them)
 * @param {Object} [arrayLikeObject] object to convert to an array
 * @return {Array} our NodeList is now an array so can use array methods on it
 */
"use strict";

var toArray = function toArray(arrayLikeObject) {
  return Array.prototype.slice.call(arrayLikeObject);
};

module.exports = toArray;

},{}],36:[function(require,module,exports){
'use strict';
var proto = require('./proto');

// initialize the app
var App = (function (input) {
	this.listeners = this.listeners || [];

	if (typeof input === 'string') {
		this.sel = this.query(input);
	}

	console.dir(this);

	return this;
}).bind(Object.create(proto));

if (typeof window !== 'undefined') {
	window.$ = App;
}
module.exports = App;

},{"./proto":30}]},{},[36]);

//# sourceMappingURL=app.min.js.map