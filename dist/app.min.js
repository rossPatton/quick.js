(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _stampit = require('stampit');

var _stampit2 = _interopRequireDefault(_stampit);

var Cache = (0, _stampit2['default'])().state({
	cache: {}
});

module.exports = Cache;

},{"stampit":30}],2:[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _stampit = require('stampit');

var _stampit2 = _interopRequireDefault(_stampit);

var _utilsQueryAll = require('../utils/queryAll');

var _utilsQueryAll2 = _interopRequireDefault(_utilsQueryAll);

var Init = function Init(str) {
	return (0, _stampit2['default'])().enclose(function () {
		if (typeof str === 'string') {
			this.originalString = str;
			this.selection = (0, _utilsQueryAll2['default'])(str);
		}

		return this;
	});
};

module.exports = Init;

},{"../utils/queryAll":10,"stampit":30}],3:[function(require,module,exports){
// adds a class to the current selection
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
var addClass = function addClass(classes) {
	if (typeof classes !== 'string') {
		throw Error('addClass needs a string');
	}

	classes = classes.split(' ');

	this.selection.forEach(function (sel) {
		return classes.forEach(function (className) {
			if (!sel.classList.contains(className)) {
				sel.className += ' ' + className;
			}
		});
	});

	return this;
};

exports['default'] = addClass;
module.exports = exports['default'];

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
var each = function each(cb) {
	var len = this.selection.length;
	var i = 0;

	for (i; i < len; i++) {
		cb(this.selection[i], i, this.selection);
	}

	return this;
};

exports["default"] = each;
module.exports = exports["default"];

},{}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _stampit = require('stampit');

var _stampit2 = _interopRequireDefault(_stampit);

var _on = require('./on');

var _on2 = _interopRequireDefault(_on);

var _off = require('./off');

var _off2 = _interopRequireDefault(_off);

var _addClass = require('./addClass');

var _addClass2 = _interopRequireDefault(_addClass);

var _each = require('./each');

var _each2 = _interopRequireDefault(_each);

var _setFn = require('./setFn');

var _setFn2 = _interopRequireDefault(_setFn);

var _removeClass = require('./removeClass');

var _removeClass2 = _interopRequireDefault(_removeClass);

var Methods = (0, _stampit2['default'])().methods({
	on: _on2['default'],
	off: _off2['default'],
	setFn: _setFn2['default'],
	each: _each2['default'],
	addClass: _addClass2['default'],
	removeClass: _removeClass2['default']
});

exports['default'] = Methods;
module.exports = exports['default'];

},{"./addClass":3,"./each":4,"./off":6,"./on":7,"./removeClass":8,"./setFn":9,"stampit":30}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
var off = function off(events, cb) {
	var capture = arguments[2] === undefined ? false : arguments[2];

	if (typeof events !== 'string') {
		throw TypeError('off requires a string');
	}

	var eventsArr = events.split(' ');
	var sLen = this.selection.length;
	var eLen = events.length;

	// 1 for each selection
	// 2 for each event
	for (var i = 0; i < sLen; i++) {
		// 1
		for (var j = 0; j < eLen; j++) {
			// 2
			this.selection[i].removeEventListener(eventsArr[j], cb.bind(this.selection[i]), false);
		}
	}

	return this;
};

exports['default'] = off;
module.exports = exports['default'];

},{}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
var on = function on(events, cb) {
	var capture = arguments[2] === undefined ? false : arguments[2];

	if (typeof events !== 'string') {
		throw TypeError('on requires a string');
	}

	var eventsArr = events.split(' ');
	var sLen = this.selection.length;
	var eLen = events.length;

	// 1 for each selection
	// 2 for each event
	for (var i = 0; i < sLen; i++) {
		// 1
		for (var j = 0; j < eLen; j++) {
			// 2
			this.selection[i].addEventListener(eventsArr[j], cb.bind(this.selection[i]), capture);
		}
	}

	return this;
};

exports['default'] = on;
module.exports = exports['default'];

},{}],8:[function(require,module,exports){
// remove classes
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
var removeClass = function removeClass(classes) {
	if (typeof classes !== 'string') {
		throw Error('removeClass needs a string');
	}

	classes = classes.split(' ');

	this.selection.forEach(function (sel) {
		return classes.forEach(function (className) {
			if (sel.classList.contains(className)) {
				sel.classList.remove(className);
			}
		});
	});

	return this;
};

exports['default'] = removeClass;
module.exports = exports['default'];

},{}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _stampit = require('stampit');

var _stampit2 = _interopRequireDefault(_stampit);

var _coreInit = require('../core/init');

var _coreInit2 = _interopRequireDefault(_coreInit);

var _methods = require('./methods');

var _methods2 = _interopRequireDefault(_methods);

var setFn = function setFn(fns) {
	var newMethods = (0, _stampit2['default'])().methods(fns);
	return (0, _stampit2['default'])().compose(cache, _methods2['default'], newMethods, (0, _coreInit2['default'])(arguments)).create();
};

exports['default'] = setFn;

// for ( let method in newMethods ) {
// 	if ( newMethods.hasOwnProperty( method ) && typeof method === 'function' ) {
// 		this.__proto__.fn[method] = method;
// 	}
// }
module.exports = exports['default'];

},{"../core/init":2,"./methods":5,"stampit":30}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _toArray = require('./toArray');

var _toArray2 = _interopRequireDefault(_toArray);

/**
 * @description save the result of a dom query
 * 	            this is accessible app wide, so you don't have to constantly
 * 	            do dom lookups for each thing every time a function is called
 * 	            also gives you an array, which is more usable than a nodelist
 * @see https://eamann.com/tech/selector-caching-jquery/
 * @param {string} [sel] [the string we'll use to get dom nodes]
 * @param {parent} [obj] [where to search]
 * @param {obj} [cache] [where to store the cache, defaults to this]
 * @param {bool} [bust] [if true, we ignore the cache and get it fresh]
 * @return {array} [our node list, as an array]
 */
var queryAll = function queryAll(sel) {
	var parent = arguments[1] === undefined ? document : arguments[1];
	var cache = arguments[2] === undefined ? {} : arguments[2];
	var bust = arguments[3] === undefined ? false : arguments[3];

	if (typeof sel !== 'string') {
		return console.error('query requires a string as its first param');
	}

	if (bust === true || typeof cache[sel] === 'undefined') {
		cache[sel] = (0, _toArray2['default'])(parent.querySelectorAll(sel));
	}

	return cache[sel];
};

exports['default'] = queryAll;
module.exports = exports['default'];

},{"./toArray":11}],11:[function(require,module,exports){
/**
 * @description converts nodeLists (and other things) to arrays
 * (allows you to use array methods on them)
 * @param {object} [arrayLikeObject] [object to convert]
 * @return {array} [our NodeList is now an array so can use array methods on it]
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var toArray = function toArray(arrayLikeObject) {
  return Array.prototype.slice.call(arrayLikeObject);
};

exports["default"] = toArray;
module.exports = exports["default"];

},{}],12:[function(require,module,exports){
var forIn = require('mout/object/forIn');

function copyProp(val, key){
    this[key] = val;
}

module.exports = function mixInChain(target, objects){
    var i = 0,
        n = arguments.length,
        obj;
    while(++i < n){
        obj = arguments[i];
        if (obj != null) {
            forIn(obj, copyProp, target);
        }
    }
    return target;
};

},{"mout/object/forIn":25}],13:[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],14:[function(require,module,exports){
var forEach = require('./forEach');
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":15,"./forEach":13}],15:[function(require,module,exports){
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        switch(typeof src) {
            case 'object':
                // typeof null == "object"
                return (src != null)? function(val, key, target){
                    return deepMatches(val, src);
                } : src;
            case 'string':
            case 'number':
                return prop(src);
            case 'function':
                if (typeof thisObj === 'undefined') {
                    return src;
                } else {
                    return function(val, i, arr){
                        return src.call(thisObj, val, i, arr);
                    };
                }
            default:
                return src;
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":24,"./prop":16}],16:[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],17:[function(require,module,exports){
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');
var mixIn = require('../object/mixIn');

    /**
     * Clone native types.
     */
    function clone(val){
        switch (kindOf(val)) {
            case 'Object':
                return cloneObject(val);
            case 'Array':
                return cloneArray(val);
            case 'RegExp':
                return cloneRegExp(val);
            case 'Date':
                return cloneDate(val);
            default:
                return val;
        }
    }

    function cloneObject(source) {
        if (isPlainObject(source)) {
            return mixIn({}, source);
        } else {
            return source;
        }
    }

    function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignorecase ? 'i' : '';
        return new RegExp(r.source, flags);
    }

    function cloneDate(date) {
        return new Date(+date);
    }

    function cloneArray(arr) {
        return arr.slice();
    }

    module.exports = clone;



},{"../object/mixIn":29,"./isPlainObject":22,"./kindOf":23}],18:[function(require,module,exports){
var clone = require('./clone');
var forOwn = require('../object/forOwn');
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');

    /**
     * Recursively clone native types.
     */
    function deepClone(val, instanceClone) {
        switch ( kindOf(val) ) {
            case 'Object':
                return cloneObject(val, instanceClone);
            case 'Array':
                return cloneArray(val, instanceClone);
            default:
                return clone(val);
        }
    }

    function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
            var out = {};
            forOwn(source, function(val, key) {
                this[key] = deepClone(val, instanceClone);
            }, out);
            return out;
        } else if (instanceClone) {
            return instanceClone(source);
        } else {
            return source;
        }
    }

    function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
            out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
    }

    module.exports = deepClone;




},{"../object/forOwn":26,"./clone":17,"./isPlainObject":22,"./kindOf":23}],19:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":20}],20:[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":23}],21:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":20}],22:[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value
            && typeof value === 'object'
            && value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],23:[function(require,module,exports){


    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    module.exports = kindOf;


},{}],24:[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":19,"./forOwn":26}],25:[function(require,module,exports){


    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }

        if (_hasDontEnumBug) {
            while (key = _dontEnums[i++]) {
                // since we aren't using hasOwn check we need to make sure the
                // property was overwritten
                if (obj[key] !== Object.prototype[key]) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{}],26:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":25,"./hasOwn":27}],27:[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],28:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var deepClone = require('../lang/deepClone');
var isObject = require('../lang/isObject');

    /**
     * Deep merge objects.
     */
    function merge() {
        var i = 1,
            key, val, obj, target;

        // make sure we don't modify source element and it's properties
        // objects are passed by reference
        target = deepClone( arguments[0] );

        while (obj = arguments[i++]) {
            for (key in obj) {
                if ( ! hasOwn(obj, key) ) {
                    continue;
                }

                val = obj[key];

                if ( isObject(val) && isObject(target[key]) ){
                    // inception, deep merge objects
                    target[key] = merge(target[key], val);
                } else {
                    // make sure arrays, regexp, date, objects are cloned
                    target[key] = deepClone(val);
                }

            }
        }

        return target;
    }

    module.exports = merge;



},{"../lang/deepClone":18,"../lang/isObject":21,"./hasOwn":27}],29:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":26}],30:[function(require,module,exports){
/**
 * Stampit
 **
 * Create objects from reusable, composable behaviors.
 **
 * Copyright (c) 2013 Eric Elliott
 * http://opensource.org/licenses/MIT
 **/
'use strict';
var forEach = require('mout/array/forEach');
var mixIn = require('mout/object/mixIn');
var merge = require('mout/object/merge');
var map = require('mout/array/map');
var forOwn = require('mout/object/forOwn');
var mixInChain = require('./mixinchain.js');
var slice = [].slice;

// Avoiding JSHist W003 violations.
var create, extractFunctions, stampit, compose, isStamp, convertConstructor;

create = function (o) {
  if (arguments.length > 1) {
    throw new Error('Object.create implementation only accepts the first parameter.');
  }
  function F() {}

  F.prototype = o;
  return new F();
};

if (!Array.isArray) {
  Array.isArray = function (vArg) {
    return Object.prototype.toString.call(vArg) === "[object Array]";
  };
}

extractFunctions = function extractFunctions(arg) {
  if (typeof arg === 'function') {
    return map(slice.call(arguments), function (fn) {
      if (typeof fn === 'function') {
        return fn;
      }
    });
  } else if (typeof arg === 'object') {
    var arr = [];
    forEach(slice.call(arguments), function (obj) {
      forOwn(obj, function (fn) {
        arr.push(fn);
      });
    });
    return arr;
  } else if (Array.isArray(arg)) {
    return slice.call(arg);
  }
  return [];
};

/**
 * Return a factory function that will produce new objects using the
 * prototypes that are passed in or composed.
 *
 * @param  {Object} [methods] A map of method names and bodies for delegation.
 * @param  {Object} [state]   A map of property names and values to clone for each new object.
 * @param  {Function} [enclose] A closure (function) used to create private data and privileged methods.
 * @return {Function} factory A factory to produce objects using the given prototypes.
 * @return {Function} factory.create Just like calling the factory function.
 * @return {Object} factory.fixed An object map containing the fixed prototypes.
 * @return {Function} factory.methods Add methods to the methods prototype. Chainable.
 * @return {Function} factory.state Add properties to the state prototype. Chainable.
 * @return {Function} factory.enclose Add or replace the closure prototype. Not chainable.
 */
stampit = function stampit(methods, state, enclose) {
  var fixed = {
      methods: methods || {},
      state: state,
      enclose: extractFunctions(enclose)
    },

    factory = function factory(properties) {
      var state = merge({}, fixed.state),
        instance = mixIn(create(fixed.methods || {}),
          state, properties),
        closures = fixed.enclose,
        args = slice.call(arguments, 1);

      forEach(closures, function (fn) {
        if (typeof fn === 'function') {
          instance = fn.apply(instance, args) || instance;
        }
      });

      return instance;
    };

  return mixIn(factory, {
    create: factory,
    fixed: fixed,
    /**
     * Take n objects and add them to the methods prototype.
     * @return {Object} stamp  The factory in question (`this`).
     */
    methods: function stampMethods() {
      var obj = fixed.methods || {},
        args = [obj].concat(slice.call(arguments));
      fixed.methods = mixInChain.apply(this, args);
      return this;
    },
    /**
     * Take n objects and add them to the state prototype.
     * @return {Object} stamp  The factory in question (`this`).
     */
    state: function stampState() {
      var obj = fixed.state || {},
        args = [obj].concat(slice.call(arguments));
      fixed.state = mixIn.apply(this, args);
      return this;
    },
    /**
     * Take n functions, an array of functions, or n objects and add
     * the functions to the enclose prototype.
     * @return {Object} The factory in question (`this`).
     */
    enclose: function stampEnclose() {
      fixed.enclose = fixed.enclose
        .concat(extractFunctions.apply(null, arguments));
      return this;
    },
    /**
     * Take one or more factories produced from stampit() and
     * combine them with `this` to produce and return a new factory.
     * Combining overrides properties with last-in priority.
     * @param {[Function]|...Function} factories Stampit factories.
     * @return {Function} A new stampit factory composed from arguments.
     */
    compose: function (factories) {
      var args = Array.isArray(factories) ? factories : slice.call(arguments);
      args = [this].concat(args);
      return compose(args);
    }
  });
};

/**
 * Take two or more factories produced from stampit() and
 * combine them to produce a new factory.
 * Combining overrides properties with last-in priority.
 * @param {[Function]|...Function} factories A factory produced by stampit().
 * @return {Function} A new stampit factory composed from arguments.
 */
compose = function compose(factories) {
  factories = Array.isArray(factories) ? factories : slice.call(arguments);
  var result = stampit(),
    f = result.fixed;
  forEach(factories, function (source) {
    if (source && source.fixed) {
      if (source.fixed.methods) {
        f.methods = mixInChain(f.methods, source.fixed.methods);
      }

      if (source.fixed.state) {
        f.state = mixIn(f.state || {}, source.fixed.state);
      }

      if (source.fixed.enclose) {
        f.enclose = f.enclose.concat(source.fixed.enclose);
      }
    }
  });
  return result;
};

/**
 * Check if an object is a stamp.
 * @param {Object} obj An object to check.
 * @returns {Boolean}
 */
isStamp = function isStamp(obj) {
  return (
    typeof obj === 'function' &&
    typeof obj.fixed === 'object' &&
    typeof obj.methods === 'function' &&
    typeof obj.state === 'function' &&
    typeof obj.enclose === 'function'
    );
};

/**
 * Take an old-fashioned JS constructor and return a stampit stamp
 * that you can freely compose with other stamps.
 * @param  {Function} Constructor
 * @return {Function}             A composable stampit factory
 *                                (aka stamp).
 */
convertConstructor = function convertConstructor(Constructor) {
  return stampit().methods(Constructor.prototype).enclose(Constructor);
};

module.exports = mixIn(stampit, {
  compose: compose,
  /**
   * Alias for mixIn
   */
  extend: mixIn,
  /**
   * Take a destination object followed by one or more source objects,
   * and copy the source object properties to the destination object,
   * with last in priority overrides.
   * @param {Object} destination An object to copy properties to.
   * @param {...Object} source An object to copy properties from.
   * @returns {Object}
   */
  mixIn: mixIn,
  /**
   * Check if an object is a stamp.
   * @param {Object} obj An object to check.
   * @returns {Boolean}
   */
  isStamp: isStamp,

  convertConstructor: convertConstructor
});

},{"./mixinchain.js":12,"mout/array/forEach":13,"mout/array/map":14,"mout/object/forOwn":26,"mout/object/merge":28,"mout/object/mixIn":29}],31:[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _stampit = require('stampit');

var _stampit2 = _interopRequireDefault(_stampit);

var _coreInit = require('./core/init');

var _coreInit2 = _interopRequireDefault(_coreInit);

var _coreCache = require('./core/cache');

var _coreCache2 = _interopRequireDefault(_coreCache);

var _methodsMethods = require('./methods/methods');

var _methodsMethods2 = _interopRequireDefault(_methodsMethods);

var App = window.q = function (str) {
	return (0, _stampit2['default'])().compose(_coreCache2['default'], _methodsMethods2['default'], (0, _coreInit2['default'])(str)).create();
};

module.exports = App;

},{"./core/cache":1,"./core/init":2,"./methods/methods":5,"stampit":30}]},{},[31]);

//# sourceMappingURL=app.min.js.map